---
title: WebSocket ìë™ HTTP Fallback ì‹œìŠ¤í…œ
summary: WebSocket ì—°ê²° ë¶ˆì•ˆì •ìœ¼ë¡œ ì¸í•œ ì‹¤ì‹œê°„ ë°ì´í„° ì†ì‹¤ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ìë™ HTTP Fallback ì‹œìŠ¤í…œì„ ê°œë°œí•˜ì—¬ ê±°ë˜ í”Œë«í¼ì˜ ë°ì´í„° ì—°ì†ì„±ê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í–ˆìŠµë‹ˆë‹¤.
order: 1.8
banner: false
publish: true
tags: [ê¸°ëŠ¥ ê°œì„ ]
date: 2025-01-15
cover: /projects/thumbnails/images/websocket-fallback.png
coverAlt: "WebSocket HTTP Fallback ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜"
coverCaption: "ì‹¤ì‹œê°„ ë°ì´í„° ì—°ì†ì„± ë³´ì¥ì„ ìœ„í•œ ìë™ Fallback ì‹œìŠ¤í…œ"
coverType: diagram
coverAspectRatio: 16:9
---

## **ê°œìš”**

WebSocket ì—°ê²° ë¶ˆì•ˆì •ìœ¼ë¡œÂ ì¸í•œÂ ì‹¤ì‹œê°„Â ë°ì´í„° ì†ì‹¤ì„Â ë°©ì§€í•˜ê¸°Â ìœ„í•´Â **React Queryë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í•œÂ ìë™Â HTTPÂ Fallback ì‹œìŠ¤í…œ**ì„ ê°œë°œí•˜ì—¬ ê±°ë˜Â í”Œë«í¼ì˜ ë°ì´í„°Â ì—°ì†ì„±ê³¼ ì•ˆì •ì„±ì„Â ë³´ì¥í–ˆìŠµë‹ˆë‹¤.

ì¶”ê°€ë¡œÂ **ì°¨íŠ¸Â ì „ìš© TickHealthMonitor**ë¥¼Â í†µí•´ TradingView ì°¨íŠ¸ì˜Â ì‹¤ì‹œê°„Â ë°ì´í„° í’ˆì§ˆì„Â ë…ë¦½ì ìœ¼ë¡œÂ ëª¨ë‹ˆí„°ë§í•©ë‹ˆë‹¤.

## **ë°°ê²½**

- **WebSocket ì—°ê²° ë¶ˆì•ˆì •**: ë°±ì—”ë“œ ì†Œì¼“ ì‹œìŠ¤í…œì˜ ë¶€í•˜ ë¬¸ì œë¡œ ì¸í•´ ë©”ì‹œì§€ê°€ ì œëŒ€ë¡œ ì˜¤ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ê°„í—ì ìœ¼ë¡œ ë°œìƒ
- **ì‚¬ìš©ì ê²½í—˜ ì €í•˜**: ë°ì´í„° ì§€ì—°ìœ¼ë¡œ ì¸í•œÂ ì˜ëª»ëœ ê±°ë˜ íŒë‹¨ ë° ê¸°íšŒÂ ìƒì‹¤
- **ê¸°ì¡´ ëŒ€ì‘Â ë¶€ì¬**: ì†Œì¼“ ì¥ì•  ì‹œÂ ëŒ€ì²´Â í†µì‹  ë°©ì‹Â ë°Â ìë™Â ë³µêµ¬ ì‹œìŠ¤í…œ ë¶€ì¡±

## **ëª©í‘œ**

1. ì†Œì¼“ ë¶ˆì•ˆì •Â ì‹œì—ë„ ì‹¤ì‹œê°„ ë°ì´í„°Â ì—°ì†ì„±Â ë³´ì¥
2. ë„¤íŠ¸ì›Œí¬ ìƒíƒœì—Â ë”°ë¥¸ ìµœì  í†µì‹  ë°©ì‹ ìë™Â ì„ íƒ
3. ë¶ˆí•„ìš”í•œÂ í´ë§Â ë°©ì§€Â ë° ìì›Â íš¨ìœ¨ì Â ìš´ì˜
4. ì°¨íŠ¸ ë°ì´í„° í’ˆì§ˆ ë…ë¦½ì  ëª¨ë‹ˆí„°ë§ ê¸°ëŠ¥ ì¶”ê°€

## **ë‚´Â ì—­í• **

- TickHealthMonitorë¥¼Â í†µí•œÂ 3ë‹¨ê³„ ìƒíƒœ ê´€ë¦¬Â ì‹œìŠ¤í…œÂ êµ¬ì¶•
- WebSocketÂ â†” HTTPÂ PollingÂ ìë™ ì „í™˜ ë¡œì§Â ê°œë°œ

## **í•´ê²°ê³¼ì •**

1. **React Query ê¸°ë°˜ í•˜ì´ë¸Œë¦¬ë“œ ë°ì´í„° ê´€ë¦¬**

   ì‹œìŠ¤í…œì˜ í•µì‹¬ì€Â **React Queryì˜Â ìºì‹œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í•œ WebSocket â†” HTTP í†µí•©Â ê´€ë¦¬**ì…ë‹ˆë‹¤.

   ```mermaid
   graph TB
       subgraph "React Query Cache"
           A[QueryClient Cache]
       end

       subgraph "WebSocket Layer"
           B[useWebsocketWorkerClient] --> C[connected: boolean]
           C --> D[WebSocket Data]
           D --> E[setQueryData]
       end

       subgraph "HTTP Fallback Layer"
           F[HTTP Polling] --> G[refetchInterval]
           G --> H[connected ? 5000 : 1000]
           H --> I[HTTP Data]
           I --> J[setQueryData]
       end

       E --> A
       J --> A
       A --> K[UI Components]
   ```

   setQueryData ë‚´ë¶€ ì†ŒìŠ¤ì½”ë“œì—ì„œ ê·¼ê±°ë¥¼ ì°¾ì€ ë‚´ìš©

   [Github Discussion](https://github.com/TanStack/query/discussions/4716)

   ```mermaid
   sequenceDiagram
       participant WS as WebSocket
       participant Hook as useKlineWebSocket
       participant Client as QueryClient
       participant Cache as QueryCache
       participant Query as Query
       participant Observer as QueryObserver
       participant Timer as setInterval

       Note over WS,Timer: ì •ìƒì ì¸ ê²½ìš° - WebSocket ë°ì´í„° ìˆ˜ì‹ 
       WS->>Hook: ì‹¤ì‹œê°„ Kline ë°ì´í„°
       Hook->>Client: setQueryData(queryKey, newData)

       Note over Client,Timer: React Query ë‚´ë¶€ ì²˜ë¦¬ ê³¼ì •
       Client->>Cache: get(queryHash)
       Cache-->>Client: ê¸°ì¡´ Query ê°ì²´ ë°˜í™˜
       Client->>Query: setData(data, {manual: true})

       Note over Query: setData ë‚´ë¶€ ì²˜ë¦¬
       Query->>Query: #dispatch({type: 'success', dataUpdatedAt: undefined})
       Query->>Query: dataUpdatedAt: undefined ?? Date.now() â†’ Date.now()ë¡œ ì„¤ì •!

       Note over Query: Observerë“¤ì—ê²Œ ì•Œë¦¼
       Query->>Observer: observer.onQueryUpdate()

       Note over Observer: íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
       Observer->>Observer: #updateTimers()
       Observer->>Observer: #computeRefetchInterval()
       Observer->>Observer: #updateRefetchInterval(interval)

       Note over Observer: refetchInterval ì¬ì„¤ì •
       Observer->>Timer: clearInterval(ê¸°ì¡´)
       Observer->>Timer: setInterval(ìƒˆë¡œìš´)

       Note over Timer: HTTP polling ë¹„í™œì„±í™” (refetchInterval = false)
   ```

2. **ì°¨íŠ¸ ì „ìš© TickHealthMonitorÂ ì‹œìŠ¤í…œ**

   TradingView ì°¨íŠ¸ì˜ ì‹¤ì‹œê°„ ë°ì´í„° í’ˆì§ˆì„ ë…ë¦½ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ëŠ” 3ë‹¨ê³„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í–ˆìŠµë‹ˆë‹¤.

   **TickHealthMonitor ìƒíƒœ ì „í™˜:**
   - **Live â†’ Stale**: 2íšŒ ì—°ì† ë¯¸ìŠ¤ (25ì´ˆ ì´ˆê³¼)
   - **StaleÂ â†’Â Dead**: 5íšŒÂ ì—°ì†Â ë¯¸ìŠ¤ (ì´Â 7íšŒ)
   - **DeadÂ â†’Â Live**: ì²« ë²ˆì§¸ í‹± ìˆ˜ì‹  ì‹œÂ ì¦‰ì‹œ ë³µêµ¬

3. **ìë™Â Fallback ì‹œìŠ¤í…œ**

   WebSocketÂ â†’ HTTP PollingÂ ìë™ ì „í™˜, ì†Œì¼“ ì—°ê²° ë³µêµ¬ ì‹œ WebSocket ìë™ ë³µê·€

   ```mermaid
   sequenceDiagram
       participant UI as UI Components
       participant RQ as React Query System
       participant WS as WebSocket
       participant HTTP as HTTP API
       participant THM as TickHealthMonitor
       participant TV as TradingView Chart

       Note over UI,TV: ì •ìƒ ì—°ê²° ìƒíƒœ
       WS->>RQ: ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ 
       RQ->>UI: ê±°ë˜ ë°ì´í„° ì—…ë°ì´íŠ¸

       TV->>THM: onTick ì´ë²¤íŠ¸
       THM->>THM: ìƒíƒœ: Live
       THM->>TV: ì°¨íŠ¸ ë°ì´í„° ì •ìƒ

       Note over UI,TV: ì—°ê²° ë¶ˆì•ˆì • ìƒíƒœ
       WS--xRQ: ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨
       HTTP->>RQ: í´ë§ ê°„ê²© 1ì´ˆë¡œ ë‹¨ì¶•
       RQ->>UI: HTTP ë°ì´í„°ë¡œ ì—°ì†ì„± ìœ ì§€

       TV--xTHM: onTick ì´ë²¤íŠ¸ ì—†ìŒ
       THM->>THM: ìƒíƒœ: Stale â†’ Dead
       THM->>TV: ì°¨íŠ¸ ë°ì´í„° í’ˆì§ˆ ì €í•˜ ê°ì§€

       Note over UI,TV: ì—°ê²° ë³µêµ¬
       WS->>RQ: ì²« ë²ˆì§¸ ë°ì´í„° ìˆ˜ì‹ 
       HTTP->>RQ: í´ë§ ê°„ê²© 5ì´ˆë¡œ í™•ì¥

       TV->>THM: onTick ì´ë²¤íŠ¸ ì¬ê°œ
       THM->>THM: ìƒíƒœ: Dead â†’ Live
       THM->>TV: ì°¨íŠ¸ ë°ì´í„° í’ˆì§ˆ ì •ìƒí™”
   ```

   **ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

   ```mermaid
   graph TB
       subgraph "ê±°ë˜ ë°ì´í„° (React Query ê¸°ë°˜)"
           A[useWebsocketWorkerClient] --> B[connected: boolean]
           B --> C[WebSocket Data]
           C --> D[setQueryData]
           E[HTTP Polling] --> F[refetchInterval ì¡°ì •]
           F --> G[HTTP Data]
           G --> H[setQueryData]
           D --> I[React Query Cache]
           H --> I
       end

       subgraph "ì°¨íŠ¸ ë°ì´í„° (TickHealthMonitor ê¸°ë°˜)"
           J[TradingView onTick] --> K[TickHealthMonitor]
           K --> L[Live/Stale/Dead ìƒíƒœ]
           L --> M[ì°¨íŠ¸ ë°ì´í„° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§]
       end

       subgraph "UI Layer"
           I --> N[UI Component]
           M --> O[TradingView Chart]
       end
   ```

## ê°œì„ í•  ì 

- ë§¤ì§ ë„˜ë²„ì— ëŒ€í•œ ê¸°ì¤€ ë¶ˆëª…í™• (ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•¨)
  - TickMonitor ë‚´ì˜ íšŸìˆ˜ ë° polling ì‹œê°„ì´ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ì ì ˆíˆ ì„¤ì •ì´ ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

## setQueryData ë‚´ë¶€ ë¡œì§ 

queryClient ì‹œ setQueryData í˜¸ì¶œì‹œ options.updatedAtì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë„£ì§€ ì•Šìœ¼ë©´ Date.now()ë¡œ ìë™ ì„¤ì •
â†’ ì´ë¡œ ì¸í•´ WebSocketìœ¼ë¡œ ì‹¤ì‹œê°„ ë°ì´í„°ë¥¼ ë°›ì„ ë•Œë§ˆë‹¤ refetchTimeì´ ì´ˆê¸°í™”ë˜ì–´, HTTP pollingì˜ refetchInterval ê³„ì‚°ì´ ì´ˆê¸°í™”ëœë‹¤.

- 1ë‹¨ê³„: [setQueryData](https://github.com/TanStack/query/blob/2a00fb6504e777fa1a9c9a46ce9f1b7ccdb3835a/packages/query-core/src/queryClient.ts#L176) í˜¸ì¶œ

  ```tsx
  setQueryData<
      TQueryFnData = unknown,
      TTaggedQueryKey extends QueryKey = QueryKey,
      TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,
    >(
      queryKey: TTaggedQueryKey,
      updater: Updater<
        NoInfer<TInferredQueryFnData> | undefined,
        NoInfer<TInferredQueryFnData> | undefined
      >,
      options?: SetDataOptions,
    ): NoInfer<TInferredQueryFnData> | undefined {
      const defaultedOptions = this.defaultQueryOptions<
        any,
        any,
        unknown,
        any,
        QueryKey
      >({ queryKey })

      const query = this.#queryCache.get<TInferredQueryFnData>(
        defaultedOptions.queryHash,
      )
      const prevData = query?.state.data
      const data = functionalUpdate(updater, prevData)

      if (data === undefined) {
        return undefined
      }

      return this.#queryCache
        .build(this, defaultedOptions)
        .setData(data, { ...options, manual: true })
    }
  ```
  - queryCacheì—ì„œ ê¸°ì¡´ ì¿¼ë¦¬ë¥¼ ê°€ì ¸ì˜´
  - ì´ì „ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ì„œ functionalUpdateë¡œ ìƒˆ ë°ì´í„° ìƒì„±
  - queryCache.build()ë¡œ ì¿¼ë¦¬ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  setData() í˜¸ì¶œ

- **2ë‹¨ê³„: queryCache.build() â†’ [setData()](https://github.com/TanStack/query/blob/main/packages/query-core/src/query.ts#L228) í˜¸ì¶œ**

  ```tsx
  setData(
      newData: TData,
      options?: SetDataOptions & { manual: boolean },
    ): TData {
      const data = replaceData(this.state.data, newData, this.options)

      // Set data and mark it as cached
      this.#dispatch({
        data,
        type: 'success',
        dataUpdatedAt: options?.updatedAt,
        manual: options?.manual,
      })

      return data
    }
  ```

  **ì½”ë“œ ë¶„ì„:**
  - replaceDataë¡œ ìƒˆ ë°ì´í„° ì²˜ë¦¬
  - #dispatch í˜¸ì¶œí•˜ì—¬ 'success' ì•¡ì…˜ ì „ë‹¬
  - options?.updatedAtì´ ì „ë‹¬ë¨ (ê¸°ë³¸ê°’ì€ undefined)

- 3ë‹¨ê³„: [\*\*#dispatch](https://github.com/TanStack/query/blob/main/packages/query-core/src/query.ts#L608) â†’ dataUpdatedAt ê°±ì‹ \*\*

  ```tsx
  #dispatch(action: Action<TData, TError>): void {
      const reducer = (
        state: QueryState<TData, TError>,
      ): QueryState<TData, TError> => {
        switch (action.type) {
          case 'failed':
            return {
              ...state,
              fetchFailureCount: action.failureCount,
              fetchFailureReason: action.error,
            }
          case 'pause':
            return {
              ...state,
              fetchStatus: 'paused',
            }
          case 'continue':
            return {
              ...state,
              fetchStatus: 'fetching',
            }
          case 'fetch':
            return {
              ...state,
              ...fetchState(state.data, this.options),
              fetchMeta: action.meta ?? null,
            }
          case 'success':
            return {
              ...state,
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: false,
              status: 'success',
              ...(!action.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null,
              }),
            }
          case 'error':
            const error = action.error

            if (isCancelledError(error) && error.revert && this.#revertState) {
              return { ...this.#revertState, fetchStatus: 'idle' }
            }

            return {
              ...state,
              error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              fetchFailureReason: error,
              fetchStatus: 'idle',
              status: 'error',
            }
          case 'invalidate':
            return {
              ...state,
              isInvalidated: true,
            }
          case 'setState':
            return {
              ...state,
              ...action.state,
            }
        }
      }

      this.state = reducer(this.state)

      notifyManager.batch(() => {
        this.observers.forEach((observer) => {
          observer.onQueryUpdate()
        })

        this.#cache.notify({ query: this, type: 'updated', action })
      })
    }
  ```
  - dataUpdatedAt: action.dataUpdatedAt ?? Date.now()
    - setQueryDataì—ì„œ options?.updatedAtì´ undefinedì´ë¯€ë¡œ **Date.now()ë¡œ ì„¤ì •ë¨**
  - dataUpdateCountë„ ì¦ê°€
  - ëª¨ë“  observerì—ê²Œ onQueryUpdate() í˜¸ì¶œ
  - ì´ëŠ” refetchIntervalì„ ê´€ë¦¬í•˜ëŠ” QueryObserverë“¤ì—ê²Œ ì•Œë¦¼ì„ ë³´ë‚´ëŠ” í•µì‹¬ ë¶€ë¶„

- 5ë‹¨ê³„: [\*\*QueryObserver.onQueryUpdate()](https://github.com/TanStack/query/blob/main/packages/query-core/src/queryObserver.ts#L721) í˜¸ì¶œ\*\*

  ```tsx
    onQueryUpdate(): void {
      this.updateResult()

      if (this.hasListeners()) {
        this.#updateTimers()
      }
    }
  ```
  - #updateTimers() í˜¸ì¶œ - **ì—¬ê¸°ì„œ refetchInterval ì¬ê³„ì‚° ì‹œì‘**

- **6ë‹¨ê³„: [#updateTimers()](https://github.com/TanStack/query/blob/main/packages/query-core/src/queryObserver.ts#L409) â†’ #updateRefetchInterval() í˜¸ì¶œ (queryObserver.ts 414-417ë²ˆì§¸ ì¤„)**

  ```tsx
    #updateTimers(): void {
      this.#updateStaleTimeout()
      this.#updateRefetchInterval(this.#computeRefetchInterval())
    }

  ```
  - #computeRefetchInterval()ë¡œ ìƒˆë¡œìš´ interval ê³„ì‚° í›„ #updateRefetchInterval() í˜¸ì¶œ

- **7ë‹¨ê³„: [#computeRefetchInterval()](https://github.com/TanStack/query/blob/main/packages/query-core/src/queryObserver.ts#L377C3-L383C4) ê³„ì‚°**
  ```tsx
   #computeRefetchInterval() {
      return (
        (typeof this.options.refetchInterval === 'function'
          ? this.options.refetchInterval(this.#currentQuery)
          : this.options.refetchInterval) ?? false
      )
    }
  ```
  **ì½”ë“œ ë¶„ì„:**
  - refetchIntervalì´ í•¨ìˆ˜ì¸ì§€ í™•ì¸í•˜ê³ , í•¨ìˆ˜ë©´ í˜„ì¬ ì¿¼ë¦¬ë¥¼ ì „ë‹¬í•˜ì—¬ ê³„ì‚°
  - ê¸°ë³¸ê°’ì€ false
- **8ë‹¨ê³„: [#updateRefetchInterval()](https://github.com/TanStack/query/blob/main/packages/query-core/src/queryObserver.ts#L385) ì‹¤í–‰**

  ```tsx
  #updateRefetchInterval(nextInterval: number | false): void {
      this.#clearRefetchInterval()

      this.#currentRefetchInterval = nextInterval

      if (
        isServer ||
        resolveEnabled(this.options.enabled, this.#currentQuery) === false ||
        !isValidTimeout(this.#currentRefetchInterval) ||
        this.#currentRefetchInterval === 0
      ) {
        return
      }

      this.#refetchIntervalId = setInterval(() => {
        if (
          this.options.refetchIntervalInBackground ||
          focusManager.isFocused()
        ) {
          this.#executeFetch()
        }
      }, this.#currentRefetchInterval)
    }

      #clearRefetchInterval(): void {
      if (this.#refetchIntervalId) {
        clearInterval(this.#refetchIntervalId)
        this.#refetchIntervalId = undefined
      }
    }
  ```

  **ì½”ë“œ ë¶„ì„:**
  - #clearRefetchInterval() - **ê¸°ì¡´ setInterval ì •ë¦¬**
  - ìƒˆë¡œìš´ interval ê°’ ì €ì¥
  - **ìƒˆë¡œìš´ setInterval ìƒì„±** - #executeFetch() í˜¸ì¶œ

---

ìš”ì•½

```tsx
// 1. setQueryData í˜¸ì¶œ
queryClient.setQueryData(queryKey, newData)
  â†“
// 2. queryCacheì—ì„œ ì¿¼ë¦¬ ê°€ì ¸ì˜¤ê¸° (queryClient.ts:217-219)
const query = this.#queryCache.get<TInferredQueryFnData>(defaultedOptions.queryHash)
  â†“
// 3. setData í˜¸ì¶œ (queryClient.ts:227-229)
this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true })
  â†“
// 4. #dispatch í˜¸ì¶œ (query.ts:218-223)
this.#dispatch({
  data,
  type: 'success',
  dataUpdatedAt: options?.updatedAt,  // undefined
  manual: options?.manual,
})
  â†“
// 5. dataUpdatedAt ê°±ì‹  (query.ts:575)
dataUpdatedAt: action.dataUpdatedAt ?? Date.now()  // Date.now()ë¡œ ì„¤ì •!
  â†“
// 6. ëª¨ë“  observerì—ê²Œ ì•Œë¦¼ (query.ts:618-620)
this.observers.forEach((observer) => {
  observer.onQueryUpdate()
})
  â†“
// 7. QueryObserver.onQueryUpdate() í˜¸ì¶œ (queryObserver.ts:735-740)
onQueryUpdate(): void {
  this.updateResult()
  if (this.hasListeners()) {
    this.#updateTimers()  // ğŸ”¥ ì—¬ê¸°ì„œ refetchInterval ì¬ê³„ì‚°!
  }
}
  â†“
// 8. #updateTimers() í˜¸ì¶œ (queryObserver.ts:414-417)
#updateTimers(): void {
  this.#updateStaleTimeout()
  this.#updateRefetchInterval(this.#computeRefetchInterval())
}
  â†“
// 9. #computeRefetchInterval() ê³„ì‚° (queryObserver.ts:382-388)
#computeRefetchInterval() {
  return (typeof this.options.refetchInterval === 'function'
    ? this.options.refetchInterval(this.#currentQuery)
    : this.options.refetchInterval) ?? false
}
  â†“
// 10. #updateRefetchInterval() ì‹¤í–‰ (queryObserver.ts:390-412)
#updateRefetchInterval(nextInterval: number | false): void {
  this.#clearRefetchInterval()  // ê¸°ì¡´ setInterval ì •ë¦¬
  this.#currentRefetchInterval = nextInterval

  // ìƒˆë¡œìš´ setInterval ìƒì„±
  this.#refetchIntervalId = setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      this.#executeFetch()
    }
  }, this.#currentRefetchInterval)
}
```

---

ì½”ë“œ ë§¤ì»¤ë‹ˆì¦˜

**ì „ì²´ íë¦„:**

1. **setQueryData í˜¸ì¶œ** â†’ dataUpdatedAtì´ Date.now()ë¡œ ê°±ì‹ 
2. **#dispatch ì‹¤í–‰** â†’ 'success' ì•¡ì…˜ìœ¼ë¡œ ìƒíƒœ ì—…ë°ì´íŠ¸
3. **ëª¨ë“  observerì—ê²Œ onQueryUpdate() í˜¸ì¶œ**
4. **onQueryUpdate()ì—ì„œ #updateTimers() í˜¸ì¶œ**
5. **#updateTimers()ì—ì„œ #updateRefetchInterval() í˜¸ì¶œ**
6. **#computeRefetchInterval()ë¡œ ìƒˆë¡œìš´ interval ê³„ì‚°**
7. **ê¸°ì¡´ setInterval ì •ë¦¬ í›„ ìƒˆë¡œìš´ setInterval ìƒì„±**

```mermaid
sequenceDiagram
    participant Client as QueryClient
    participant Cache as QueryCache
    participant Query as Query
    participant Observer as QueryObserver
    participant Timer as setInterval

    Note over Client: 1. setQueryData í˜¸ì¶œ
    Client->>Cache: get(queryHash)
    Cache-->>Client: ê¸°ì¡´ Query ê°ì²´ ë°˜í™˜

    Client->>Cache: build(client, options)
    Cache-->>Client: Query ê°ì²´ ìƒì„±

    Client->>Query: setData(data, {manual: true})

    Note over Query: 2. setData ë‚´ë¶€ ì²˜ë¦¬
    Query->>Query: replaceData(oldData, newData)
    Query->>Query: #dispatch({type: 'success', dataUpdatedAt: undefined})

    Note over Query: 3. #dispatch ì‹¤í–‰
    Query->>Query: reducer ì‹¤í–‰
    Note over Query: dataUpdatedAt: undefined ?? Date.now()<br/>â†’ Date.now()ë¡œ ì„¤ì •!

    Note over Query: 4. Observerë“¤ì—ê²Œ ì•Œë¦¼
    Query->>Observer: observer.onQueryUpdate()

    Note over Observer: 5. onQueryUpdate ì²˜ë¦¬
    Observer->>Observer: updateResult()
    Observer->>Observer: #updateTimers()

    Note over Observer: 6. íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
    Observer->>Observer: #updateStaleTimeout()
    Observer->>Observer: #computeRefetchInterval()
    Observer->>Observer: #updateRefetchInterval(interval)

    Note over Observer: 7. refetchInterval ì¬ì„¤ì •
    Observer->>Timer: clearInterval(ê¸°ì¡´)
    Observer->>Timer: setInterval(ìƒˆë¡œìš´)

    Note over Timer: 8. ìƒˆë¡œìš´ polling ì‹œì‘
    Timer-->>Observer: #executeFetch() (ì£¼ê¸°ì  í˜¸ì¶œ)
```

- í´ë˜ìŠ¤ë³„ ì—­í• 

  ```mermaid
  classDiagram
      class QueryClient {
          -queryCache: QueryCache
          +setQueryData(queryKey, updater, options)
          +getQueryCache()
      }

      class QueryCache {
          -queries: Map
          +get(queryHash) Query
          +build(client, options) Query
          +notify(event)
      }

      class Query {
          -state: QueryState
          -observers: QueryObserver[]
          +setData(newData, options)
          -dispatch(action)
          +fetch()
      }

      class QueryObserver {
          -currentQuery: Query
          -refetchIntervalId: number
          -currentRefetchInterval: number
          +onQueryUpdate()
          -updateTimers()
          -updateRefetchInterval()
          -computeRefetchInterval()
          -executeFetch()
      }

      class QueryState {
          +data: any
          +dataUpdatedAt: number
          +dataUpdateCount: number
          +status: QueryStatus
      }

      QueryClient --> QueryCache : uses
      QueryCache --> Query : manages
      Query --> QueryObserver : notifies
      Query --> QueryState : contains
      QueryObserver --> Query : observes
  ```
