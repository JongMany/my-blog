
## ê°œìš”

AI ìºë¦­í„° í”Œë«í¼ì—ì„œ ì‚¬ìš©ìê°€ íŠ¸ë¦¬ê±° ì´ë¯¸ì§€ë¥¼ êµ¬ë§¤í•˜ê³  ì—…ë¡œë“œí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. React 18ì˜ flushSyncë¥¼ í™œìš©í•´ ì´ë¯¸ì§€ êµ¬ë§¤ APIë¥¼ ì¤‘ë³µ í˜¸ì¶œì„ ì›ì²œ ì°¨ë‹¨í•˜ê³ , êµ¬ë§¤ ì¦‰ì‹œ ì±„íŒ… ë°°ê²½ ë™ê¸°í™”ë¡œ ê²°ì œ ì•ˆì •ì„±ê³¼ ì‚¬ìš©ì ê²½í—˜ì„ ê°œì„ í–ˆìŠµë‹ˆë‹¤.

## ë°°ê²½/ë¬¸ì œ

- **ê²°ì œ ë²„íŠ¼ ì—°ì† í´ë¦­**: APIê°€ ì¤‘ë³µ í˜¸ì¶œë˜ì–´ ì´ì¤‘ ê²°ì œ/ì˜¤ë¥˜ ìœ„í—˜ì´ ì¡´ì¬í–ˆìŠµë‹ˆë‹¤
- **ë„¤íŠ¸ì›Œí¬ ì§€ì—°**: í”¼ë“œë°±ì´ ëŠ¦ì–´ ì‚¬ìš©ìê°€ ë¶ˆì•ˆê°ì„ ëŠë¼ê³  ì¬í´ë¦­ì„ ìœ ë°œí–ˆìŠµë‹ˆë‹¤
- **UI ë°˜ì˜ ì§€ì—°**: êµ¬ë§¤ ì™„ë£Œ í›„ ì ê¸ˆ í•´ì œ/ë°°ê²½ ê°±ì‹ ì´ ì¼ê´€ë˜ì§€ ì•Šê²Œ ë³´ì´ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤

## ëª©í‘œ

1. **ê²°ì œ ì•ˆì •ì„± í™•ë³´**: ì¤‘ë³µ í´ë¦­ìœ¼ë¡œ ì¸í•œ ì´ë¯¸ì§€ êµ¬ë§¤ API ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
2. **UI ë™ê¸°í™”**: êµ¬ë§¤ ì™„ë£Œ ì‹œ ì´ë¯¸ì§€ ì ê¸ˆ í•´ì œ, ë°°ê²½ ì´ë¯¸ì§€ ê´€ë ¨ ì»´í¬ë„ŒíŠ¸ë¥¼ ì‹¤ì‹œê°„ ê°±ì‹ 

## ì—­í• 

- **ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ í›… ì„¤ê³„**: React 18ì˜ flushSyncë¥¼ í™œìš©í•œ ë™ê¸°ì  ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- **ê²°ì œ í”Œë¡œìš° ìµœì í™”**: íŠ¸ë¦¬ê±° ì´ë¯¸ì§€ êµ¬ë§¤ í”„ë¡œì„¸ìŠ¤ì˜ ì•ˆì •ì„± ë° ì‚¬ìš©ì ê²½í—˜ ê°œì„ 

## í•´ê²°ê³¼ì •

### API ì¤‘ë³µ í˜¸ì¶œ ë¬¸ì œ í•´ê²°

#### ë¬¸ì œ ì›ì¸ ë¶„ì„

- **API í˜¸ì¶œ íƒ€ì´ë°**: í”„ë¡œì„¸ìŠ¤ ì²˜ë¦¬ ê´€ë ¨ ìƒíƒœ ë³€ê²½ê³¼ API í˜¸ì¶œ ì‚¬ì´ì˜ ì‹œê°„ ê°„ê²©ì—ì„œ ë°œìƒí•˜ëŠ” ë ˆì´ìŠ¤ ì»¨ë””ì…˜

#### flushSync ê¸°ë°˜ ë™ê¸°ì  ìƒíƒœ ê´€ë¦¬

```typescript
// useImagePurchase.ts
import { useState, useCallback } from "react";
import { flushSync } from "react-dom";

interface PurchaseState {
  isPurchasing: boolean;
  purchasedImages: string[];
  error: string | null;
}

export const useImagePurchase = () => {
  const [state, setState] = useState<PurchaseState>({
    isPurchasing: false,
    purchasedImages: [],
    error: null,
  });

  const purchaseImage = useCallback(async (imageId: string) => {
    // flushSyncë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒíƒœë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    flushSync(() => {
      setState((prev) => ({
        ...prev,
        isPurchasing: true,
        error: null,
      }));
    });

    try {
      const response = await fetch("/api/images/purchase", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ imageId }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Purchase failed");
      }

      const result = await response.json();

      // êµ¬ë§¤ ì„±ê³µ ì‹œ ìƒíƒœë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
      flushSync(() => {
        setState((prev) => ({
          ...prev,
          isPurchasing: false,
          purchasedImages: [...prev.purchasedImages, imageId],
        }));
      });

      return result;
    } catch (error) {
      // ì—ëŸ¬ ë°œìƒ ì‹œ ìƒíƒœë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
      flushSync(() => {
        setState((prev) => ({
          ...prev,
          isPurchasing: false,
          error: error instanceof Error ? error.message : "Unknown error",
        }));
      });
      throw error;
    }
  }, []);

  return {
    ...state,
    purchaseImage,
  };
};
```

#### ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ ì»´í¬ë„ŒíŠ¸

```typescript
// ImagePurchaseButton.tsx
import React from 'react';
import { useImagePurchase } from './useImagePurchase';

interface ImagePurchaseButtonProps {
  imageId: string;
  price: number;
  onPurchaseSuccess?: (imageId: string) => void;
  onPurchaseError?: (error: string) => void;
}

export const ImagePurchaseButton: React.FC<ImagePurchaseButtonProps> = ({
  imageId,
  price,
  onPurchaseSuccess,
  onPurchaseError,
}) => {
  const { isPurchasing, error, purchaseImage } = useImagePurchase();

  const handlePurchase = async () => {
    if (isPurchasing) {
      return; // ì´ë¯¸ êµ¬ë§¤ ì¤‘ì´ë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    }

    try {
      const result = await purchaseImage(imageId);
      onPurchaseSuccess?.(imageId);
    } catch (error) {
      onPurchaseError?.(error instanceof Error ? error.message : 'Purchase failed');
    }
  };

  return (
    <button
      onClick={handlePurchase}
      disabled={isPurchasing}
      className={`purchase-button ${isPurchasing ? 'purchasing' : ''}`}
    >
      {isPurchasing ? (
        <div className="purchasing-state">
          <div className="spinner" />
          <span>êµ¬ë§¤ ì¤‘...</span>
        </div>
      ) : (
        <div className="purchase-content">
          <span className="price">{price.toLocaleString()}ì›</span>
          <span className="action">êµ¬ë§¤í•˜ê¸°</span>
        </div>
      )}
      {error && (
        <div className="error-message">
          {error}
        </div>
      )}
    </button>
  );
};
```

### ì—ëŸ¬ ì²˜ë¦¬ ë° ì‚¬ìš©ì í”¼ë“œë°±

#### ìƒí™©ë³„ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```typescript
// PurchaseErrorHandler.ts
export class PurchaseErrorHandler {
  static handleError(error: any): {
    message: string;
    type: "error" | "warning";
  } {
    if (error.response?.status === 400) {
      if (error.response.data?.code === "INSUFFICIENT_BALANCE") {
        return {
          message: "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë¨¼ì € ì¶©ì „í•´ì£¼ì„¸ìš”.",
          type: "error",
        };
      }
      if (error.response.data?.code === "ALREADY_PURCHASED") {
        return {
          message: "ì´ë¯¸ êµ¬ë§¤í•œ ì´ë¯¸ì§€ì…ë‹ˆë‹¤.",
          type: "warning",
        };
      }
    }

    if (error.response?.status === 429) {
      return {
        message: "ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
        type: "warning",
      };
    }

    if (error.response?.status >= 500) {
      return {
        message:
          "ì„œë²„ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
        type: "error",
      };
    }

    return {
      message: "êµ¬ë§¤ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
      type: "error",
    };
  }
}
```

#### ì„±ê³µ í”¼ë“œë°± ë° UI ë™ê¸°í™”

```typescript
// PurchaseSuccessHandler.tsx
import React, { useEffect } from "react";
import { flushSync } from "react-dom";

interface PurchaseSuccessHandlerProps {
  purchasedImageId: string;
  onImageUnlock: (imageId: string) => void;
  onBackgroundUpdate: (imageId: string) => void;
  onShowSuccessModal: (imageId: string) => void;
}

export const PurchaseSuccessHandler: React.FC<PurchaseSuccessHandlerProps> = ({
  purchasedImageId,
  onImageUnlock,
  onBackgroundUpdate,
  onShowSuccessModal,
}) => {
  useEffect(() => {
    if (purchasedImageId) {
      // êµ¬ë§¤ ì™„ë£Œ ì‹œ ëª¨ë“  UI ìƒíƒœë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
      flushSync(() => {
        onImageUnlock(purchasedImageId);
        onBackgroundUpdate(purchasedImageId);
      });

      // ì„±ê³µ ëª¨ë‹¬ í‘œì‹œ
      onShowSuccessModal(purchasedImageId);
    }
  }, [purchasedImageId, onImageUnlock, onBackgroundUpdate, onShowSuccessModal]);

  return null;
};
```

### ë©€í‹° ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œìŠ¤í…œ

#### ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì—…ë¡œë“œ

```typescript
// MultiImageUpload.tsx
import React, { useState, useCallback, useRef } from 'react';
import { flushSync } from 'react-dom';

interface UploadState {
  files: File[];
  uploading: boolean;
  progress: Record<string, number>;
  errors: Record<string, string>;
}

export const MultiImageUpload: React.FC = () => {
  const [state, setState] = useState<UploadState>({
    files: [],
    uploading: false,
    progress: {},
    errors: {},
  });

  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = useCallback((files: FileList) => {
    const newFiles = Array.from(files).filter(file =>
      file.type.startsWith('image/') && file.size <= 10 * 1024 * 1024 // 10MB ì œí•œ
    );

    flushSync(() => {
      setState(prev => ({
        ...prev,
        files: [...prev.files, ...newFiles],
        errors: {},
      }));
    });
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    const files = e.dataTransfer.files;
    handleFileSelect(files);
  }, [handleFileSelect]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
  }, []);

  const uploadFiles = useCallback(async () => {
    if (state.files.length === 0) return;

    flushSync(() => {
      setState(prev => ({
        ...prev,
        uploading: true,
        progress: {},
        errors: {},
      }));
    });

    const uploadPromises = state.files.map(async (file, index) => {
      const formData = new FormData();
      formData.append('image', file);

      try {
        const response = await fetch('/api/images/upload', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          throw new Error(`Upload failed for ${file.name}`);
        }

        const result = await response.json();

        // ì—…ë¡œë“œ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        flushSync(() => {
          setState(prev => ({
            ...prev,
            progress: {
              ...prev.progress,
              [file.name]: 100,
            },
          }));
        });

        return result;
      } catch (error) {
        flushSync(() => {
          setState(prev => ({
            ...prev,
            errors: {
              ...prev.errors,
              [file.name]: error instanceof Error ? error.message : 'Upload failed',
            },
          }));
        });
        throw error;
      }
    });

    try {
      await Promise.all(uploadPromises);

      flushSync(() => {
        setState(prev => ({
          ...prev,
          uploading: false,
          files: [],
        }));
      });
    } catch (error) {
      flushSync(() => {
        setState(prev => ({
          ...prev,
          uploading: false,
        }));
      });
    }
  }, [state.files]);

  return (
    <div className="multi-image-upload">
      <div
        className="upload-area"
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onClick={() => fileInputRef.current?.click()}
      >
        <div className="upload-content">
          <div className="upload-icon">ğŸ“</div>
          <p>ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ</p>
          <p className="upload-hint">ìµœëŒ€ 10MB, JPG/PNG/GIF ì§€ì›</p>
        </div>
      </div>

      <input
        ref={fileInputRef}
        type="file"
        multiple
        accept="image/*"
        onChange={(e) => e.target.files && handleFileSelect(e.target.files)}
        style=\{\{ display: 'none' \}\}
      />

      {state.files.length > 0 && (
        <div className="file-list">
          {state.files.map((file, index) => (
            <div key={index} className="file-item">
              <div className="file-info">
                <span className="file-name">{file.name}</span>
                <span className="file-size">
                  {(file.size / 1024 / 1024).toFixed(2)}MB
                </span>
              </div>
              {state.progress[file.name] && (
                <div className="progress-bar">
                  <div
                    className="progress-fill"
                    style=\{\{ width: `${state.progress[file.name]}%` \}\}
                  />
                </div>
              )}
              {state.errors[file.name] && (
                <div className="error-message">
                  {state.errors[file.name]}
                </div>
              )}
            </div>
          ))}
        </div>
      )}

      {state.files.length > 0 && (
        <button
          onClick={uploadFiles}
          disabled={state.uploading}
          className="upload-button"
        >
          {state.uploading ? 'ì—…ë¡œë“œ ì¤‘...' : 'ì—…ë¡œë“œ ì‹œì‘'}
        </button>
      )}
    </div>
  );
};
```

### ìºì‹œ ë¬´íš¨í™” ë° ë°ì´í„° ê°±ì‹ 

#### êµ¬ë§¤ ì™„ë£Œ í›„ ìë™ ê°±ì‹ 

```typescript
// useImageCache.ts
import { useCallback } from "react";
import { useQueryClient } from "@tanstack/react-query";

export const useImageCache = () => {
  const queryClient = useQueryClient();

  const invalidateImageData = useCallback(
    (imageId: string) => {
      // ê´€ë ¨ ì¿¼ë¦¬ë“¤ì„ ë¬´íš¨í™”í•˜ì—¬ ìë™ ê°±ì‹ 
      queryClient.invalidateQueries(["images"]);
      queryClient.invalidateQueries(["user-purchases"]);
      queryClient.invalidateQueries(["chat-background"]);

      // íŠ¹ì • ì´ë¯¸ì§€ ë°ì´í„° ê°±ì‹ 
      queryClient.invalidateQueries(["image", imageId]);
    },
    [queryClient],
  );

  const updateImageStatus = useCallback(
    (imageId: string, status: "locked" | "unlocked") => {
      queryClient.setQueryData(["image", imageId], (oldData: any) => ({
        ...oldData,
        status,
      }));
    },
    [queryClient],
  );

  return {
    invalidateImageData,
    updateImageStatus,
  };
};
```

## ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```mermaid
sequenceDiagram
    participant U as User
    participant B as Purchase Button
    participant H as useImagePurchase Hook
    participant A as API Server
    participant C as Cache Manager
    participant UI as UI Components

    U->>B: êµ¬ë§¤ ë²„íŠ¼ í´ë¦­
    B->>H: purchaseImage í˜¸ì¶œ

    Note over H: flushSyncë¡œ ìƒíƒœ ë™ê¸°í™”
    H->>H: isPurchasing = true

    H->>A: POST /api/images/purchase
    A-->>H: êµ¬ë§¤ ê²°ê³¼ ë°˜í™˜

    alt êµ¬ë§¤ ì„±ê³µ
        Note over H: flushSyncë¡œ ìƒíƒœ ë™ê¸°í™”
        H->>H: isPurchasing = false<br/>purchasedImages ì—…ë°ì´íŠ¸
        H->>C: ìºì‹œ ë¬´íš¨í™”
        C->>UI: ì´ë¯¸ì§€ ì ê¸ˆ í•´ì œ
        C->>UI: ë°°ê²½ ì´ë¯¸ì§€ ê°±ì‹ 
        UI->>U: ì„±ê³µ ëª¨ë‹¬ í‘œì‹œ
    else êµ¬ë§¤ ì‹¤íŒ¨
        Note over H: flushSyncë¡œ ìƒíƒœ ë™ê¸°í™”
        H->>H: isPurchasing = false<br/>error ì„¤ì •
        UI->>U: ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
    end

    Note over U,UI: ì¤‘ë³µ í´ë¦­ ë°©ì§€ ë° ì¦‰ì‹œ í”¼ë“œë°±
```

## ì£¼ìš” ê¸°ëŠ¥

### 1. ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€

- **flushSync í™œìš©**: React 18ì˜ ë™ê¸°ì  ìƒíƒœ ì—…ë°ì´íŠ¸ë¡œ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€
- **ìƒíƒœ ê¸°ë°˜ ì œì–´**: isPurchasing ìƒíƒœë¡œ ì¤‘ë³µ í´ë¦­ ì›ì²œ ì°¨ë‹¨
- **ì¦‰ì‹œ í”¼ë“œë°±**: ë²„íŠ¼ í´ë¦­ ì¦‰ì‹œ UI ìƒíƒœ ë³€ê²½ìœ¼ë¡œ ì‚¬ìš©ì ì•ˆì‹¬

### 2. ìƒí™©ë³„ ì—ëŸ¬ ì²˜ë¦¬

- **ì”ì•¡ ë¶€ì¡±**: ëª…í™•í•œ ì¶©ì „ ì•ˆë‚´ ë©”ì‹œì§€
- **ì¤‘ë³µ êµ¬ë§¤**: ì´ë¯¸ êµ¬ë§¤í•œ ì´ë¯¸ì§€ì— ëŒ€í•œ ê²½ê³ 
- **ì„œë²„ ì˜¤ë¥˜**: ìƒí™©ë³„ ì ì ˆí•œ ì¬ì‹œë„ ì•ˆë‚´
- **ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜**: ì—°ê²° ìƒíƒœ í™•ì¸ ì•ˆë‚´

### 3. UI ë™ê¸°í™”

- **ì‹¤ì‹œê°„ ì ê¸ˆ í•´ì œ**: êµ¬ë§¤ ì™„ë£Œ ì¦‰ì‹œ ì´ë¯¸ì§€ ì ê¸ˆ í•´ì œ
- **ë°°ê²½ ì´ë¯¸ì§€ ê°±ì‹ **: ì±„íŒ… ë°°ê²½ì— êµ¬ë§¤í•œ ì´ë¯¸ì§€ ì¦‰ì‹œ ë°˜ì˜
- **ì„±ê³µ ëª¨ë‹¬**: êµ¬ë§¤ ì™„ë£Œ ì‹œ ì‹œê°ì  í™•ì¸ ì œê³µ
- **ìºì‹œ ë¬´íš¨í™”**: ê´€ë ¨ ë°ì´í„° ìë™ ê°±ì‹ ìœ¼ë¡œ ì¼ê´€ì„± ë³´ì¥

### 4. ë©€í‹° ì´ë¯¸ì§€ ì—…ë¡œë“œ

- **ë“œë˜ê·¸ ì•¤ ë“œë¡­**: ì§ê´€ì ì¸ íŒŒì¼ ì—…ë¡œë“œ ì¸í„°í˜ì´ìŠ¤
- **ì§„í–‰ë¥  í‘œì‹œ**: ê°œë³„ íŒŒì¼ë³„ ì—…ë¡œë“œ ì§„í–‰ë¥  ì‹œê°í™”
- **ì—ëŸ¬ ì²˜ë¦¬**: íŒŒì¼ë³„ ê°œë³„ ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
- **íŒŒì¼ ê²€ì¦**: í¬ê¸° ë° í˜•ì‹ ì œí•œìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´

## ê²°ê³¼

- **ì¤‘ë³µ ê²°ì œ ë¬¸ì œ í•´ê²°**: flushSyncë¥¼ í†µí•œ ë™ê¸°ì  ìƒíƒœ ê´€ë¦¬ë¡œ ì¤‘ë³µ ê²°ì œ ë¬¸ì œê°€ ì™„ì „íˆ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤
- **ì‚¬ìš©ì ê²½í—˜ ê°œì„ **: ì¦‰ì‹œ í”¼ë“œë°±ê³¼ ì‹¤ì‹œê°„ UI ë™ê¸°í™”ë¡œ ìì—°ìŠ¤ëŸ¬ìš´ êµ¬ë§¤ ê²½í—˜ ì œê³µ
- **ì•ˆì •ì„± í™•ë³´**: ì˜ˆì™¸ ìƒí™©ì—ì„œë„ ì•ˆì •ì ìœ¼ë¡œ ìƒíƒœê°€ ë³µêµ¬ë˜ë„ë¡ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤
- **ê²°ì œ ì‹ ë¢°ì„± í–¥ìƒ**: ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€ë¡œ ê²°ì œ ì‹œìŠ¤í…œì˜ ì‹ ë¢°ì„± ëŒ€í­ í–¥ìƒ

## ê¸°ìˆ  ìŠ¤íƒ

- **Frontend**: React 18, TypeScript
- **State Management**: React Hooks, flushSync
- **API**: RESTful API, FormData
- **Caching**: React Query (TanStack Query)
- **Error Handling**: Custom Error Classification
- **UI/UX**: Drag & Drop, Progress Indicators, Modal System
